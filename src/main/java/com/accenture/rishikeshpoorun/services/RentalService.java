package com.accenture.rishikeshpoorun.services;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

import javax.transaction.Transactional;

import org.jboss.logging.Logger;
import org.springframework.stereotype.Service;
import org.springframework.ui.Model;

import com.accenture.rishikeshpoorun.dao.entities.Car;
import com.accenture.rishikeshpoorun.dao.entities.Rental;
import com.accenture.rishikeshpoorun.dao.entities.User;
import com.accenture.rishikeshpoorun.dao.repositories.CarRepo;
import com.accenture.rishikeshpoorun.dao.repositories.RentalRepo;
import com.accenture.rishikeshpoorun.dao.repositories.UserRepo;
import com.accenture.rishikeshpoorun.dto.RentalDto;
import com.accenture.rishikeshpoorun.exceptions.CarNotAvailException;
import com.accenture.rishikeshpoorun.exceptions.CustomerNotFoundException;
import com.accenture.rishikeshpoorun.exceptions.DateConflictException;
import com.accenture.rishikeshpoorun.exceptions.RentalEntryNotFoundException;
import com.accenture.rishikeshpoorun.exceptions.UserStillOnLentException;

/**
 * Service Layer for Rental Entity
 * 
 * @author rishikesh.poorun
 *
 */
@Service
@Transactional
public class RentalService {

	Logger logger = Logger.getLogger(RentalService.class);

	private RentalRepo rentalRepo;
	private UserRepo customerRepo;
	private CarRepo carRepo;

	public RentalService(RentalRepo rentalRepo, UserRepo customerRepo, CarRepo carRepo) {
		this.rentalRepo = rentalRepo;
		this.carRepo = carRepo;
		this.customerRepo = customerRepo;
	}

	/**
	 * 
	 * @return A list of Car entities from the database for which car returned
	 *         attribute is true
	 */
	public List<Car> carAvailForRent() {

		return rentalRepo.allCarsAvailForRent();
	}

	public List<User> userRentOnDates(LocalDate startDate, LocalDate endDate) {
		return rentalRepo.userRentOnDates(startDate, endDate);
	}

	public List<User> userRentBetweenPeriod(LocalDate startDate, LocalDate endDate) {
		return rentalRepo.userRentBetweenPeriod(startDate, endDate);
	}

	public List<Rental> rentedBetweenPeriod(LocalDate startDate, LocalDate endDate) {
		return rentalRepo.rentalBetweenPeriod(startDate, endDate);
	}

	public List<Rental> rentedOnDates(LocalDate startDate, LocalDate endDate) {
		return rentalRepo.rentalOnDates(startDate, endDate);
	}

	/**
	 * Method() to get the total rent amount for all cars rented and returned
	 * 
	 * @return The cumulative sum of total fees of all Rental entries
	 */
	public Double amountForAllCarRented() {
		Double total = 0.0;

		// Get all the rental entries for which car has been returned
		List<Rental> rlist = rentalRepo.rentedCarReturned();

		// For each entry in the rental table, get the price and calculate days
		// Calculate the amount by product of price and amount of days
		for (Rental r : rlist) {
			LocalDate sDate = r.getStartDate();
			LocalDate eDate = r.getEndDate();
			Double price = r.getCar().getPricePerDay();

			Long days = ChronoUnit.DAYS.between(sDate, eDate);

			total += days * price;

		}

		// return the sum of all rent amount
		return total;
	}

	/**
	 * Method() to get the total rent amount for the specific car rented and
	 * returned given Car's Registration Number
	 * 
	 * @param registrationNumber
	 * @return The sum of the total fees generated by the car specified by
	 *         registrationNumber
	 */
	public Double amountForCarRented(String registrationNumber) {
		Double total = 0.0;

		// Get all the rental entries for which car has been returned
		List<Rental> rlist = rentalRepo.rentedCarReturned();

		// For each entry in the rental table, get the price and calculate days
		// Calculate the amount by product of price and amount of days for the given car
		for (Rental r : rlist) {

			// sort the list for entries matching the parameter registration number
			if (r.getCar().getRegistrationNumber() == registrationNumber) {
				LocalDate sDate = r.getStartDate();
				LocalDate eDate = r.getEndDate();
				Double price = r.getCar().getPricePerDay();

				Long days = ChronoUnit.DAYS.between(sDate, eDate);

				total += days * price;
			}

		}

		return total;
	}

	/**
	 * Method() to get the total rent amount for the specific car rented and
	 * returned for given Car JAVA ID
	 * 
	 * @param carId
	 * @return The sum of the total fees generated by the car specified by carId
	 */

	public Double amountForCarRented(Long carId) {
		Double total = 0.0;

		// Get all the rental entries for which car has been returned
		List<Rental> rlist = rentalRepo.rentedCarReturned();

		// For each entry in the rental table, get the price and calculate days
		// Calculate the amount by product of price and amount of days for the given car
		for (Rental r : rlist) {

			// sort the list for entries matching the parameter registration number
			if (r.getCar().getCarId() == carId) {
				LocalDate sDate = r.getStartDate();
				LocalDate eDate = r.getEndDate();
				Double price = r.getCar().getPricePerDay();

				Long days = ChronoUnit.DAYS.between(sDate, eDate);

				total += days * price;
			}

		}

		return total;
	}

	// Method() to get the total rent amount for the cars rented and returned for
	// given User ID
	public Double amountForUserRented(Long userId) {
		Double total = 0.0;

		// Get all the rental entries for which car has been returned
		List<Rental> rlist = rentalRepo.rentedCarReturned();

		// For each entry in the rental table, get the price and calculate days
		// Calculate the amount by product of price and amount of days for the given car
		for (Rental r : rlist) {

			// sort the list for entries matching the parameter registration number
			if (r.getUser().getUserId() == userId) {
				LocalDate sDate = r.getStartDate();
				LocalDate eDate = r.getEndDate();
				Double price = r.getCar().getPricePerDay();

				Long days = ChronoUnit.DAYS.between(sDate, eDate);

				total += days * price;
			}

		}

		return total;
	}

	// Method() to get the total rent amount for the cars rented and returned by
	// given User's National ID
	public Double amountForUserRented(String nationalId) {
		Double total = 0.0;

		// Get all the rental entries for which car has been returned
		List<Rental> rlist = rentalRepo.rentedCarReturned();

		// For each entry in the rental table, get the price and calculate days
		// Calculate the amount by product of price and amount of days for the given car
		for (Rental r : rlist) {

			// sort the list for entries matching the parameter registration number
			if (r.getUser().getNationalId() == nationalId) {
				LocalDate sDate = r.getStartDate();
				LocalDate eDate = r.getEndDate();
				Double price = r.getCar().getPricePerDay();

				Long days = ChronoUnit.DAYS.between(sDate, eDate);

				total += days * price;
			}

		}

		return total;
	}

	// Method to get the list of cars rented by user of given user Id
	public List<Car> carsRentedByUser(Long userId) throws CustomerNotFoundException {
		List<Car> list = new ArrayList<>();
		List<Rental> rlist = new ArrayList<>();

		User u = customerRepo.findById(userId).get(); // customerService.findById(userId);
		u.getRentals().forEach(rlist::add);

		for (Rental c : rlist) {
			list.add(c.getCar());
		}

		return list;
	}

	// Method to get the list of cars rented by user of given national Id
	public List<Car> carsRentedByUser(String nationalId) throws CustomerNotFoundException {
		List<Car> list = new ArrayList<>();
		List<Rental> rlist = new ArrayList<>();

		User u = customerRepo.findByNationalId(nationalId);// customerService.findByNationalId(nationalId);

		u.getRentals().forEach(rlist::add);

		for (Rental c : rlist) {
			list.add(c.getCar());
		}

		return list;
	}

	// Method to make entry for a new rental service
	public boolean createRentalEntry(Long userId, Long carId, LocalDate startDate, LocalDate endDate)
			throws DateConflictException, UserStillOnLentException, CarNotAvailException {

		// Validation criteria if not satisfied throws exception
		validateDates(startDate, endDate);
		isUserStillOnRent(userId);
		isCarAvailForRent(carId);

		Long days = ChronoUnit.DAYS.between(startDate, endDate);
		Double charges = carRepo.findById(carId).get().getPricePerDay() * days;
		Rental r = new Rental();

		r.setCar(carRepo.findById(carId).get());
		r.setUser(customerRepo.findById(userId).get());
		r.setStartDate(startDate);
		r.setEndDate(endDate);
		r.setCharges(charges);
		r.setReturned(false);

		rentalRepo.save(r);

		return true;
	}

	/**
	 * Checks if the user has an open rental entry for a car not yet returned
	 * 
	 * @param userId
	 * @return <b>False</b> if the user is not renting a car else returns, else
	 *         <b>Throws</b>
	 * @throws UserStillOnLentException
	 *             and logs the error status
	 */
	public boolean isUserStillOnRent(Long userId) throws UserStillOnLentException {
		// if user has no car rented, null is returned
		if (rentalRepo.isUserOnLent(userId) != null) {

			String status = String.format(
					"User [Name: %s NIC: %s] is already renting a car [%s] till: %s. Cannot make second rent request!",
					customerRepo.findById(userId).get().getName(), customerRepo.findById(userId).get().getNationalId(),
					rentalRepo.isUserOnLent(userId).getCar().getRegistrationNumber(),
					rentalRepo.isUserOnLent(userId).getEndDate());
			logger.error("ErrorStatus: " + status);
			throw new UserStillOnLentException(status);
		} else {
			return false;
		}
	}

	private void isCarAvailForRent(Long carId) throws CarNotAvailException {
		// if the car is available for rent, null is returned
		if (rentalRepo.isCarAvail(carId) != null) {

			String status = String.format("This car [Registration: %s] is not available and on rent till: %s",
					carRepo.findById(carId).get().getRegistrationNumber(), rentalRepo.isCarAvail(carId).getEndDate());

			throw new CarNotAvailException(status);
		}

	}

	private void validateDates(LocalDate startDate, LocalDate endDate) throws DateConflictException {
		if (startDate.isAfter(endDate)) {
			throw new DateConflictException("The Start Date [" + startDate.toString()
					+ "] cannot occur after the End Date [" + endDate.toString() + "]!");
		}

		if (startDate.isBefore(LocalDate.now())) {
			throw new DateConflictException("The Start Date [" + startDate.toString() + "] must be a futur date!");
		}

		if (endDate.isBefore(LocalDate.now())) {
			throw new DateConflictException(
					"The End Date [" + endDate.toString() + "] cannot occur prior the Start Date!");
		}

		if (startDate.equals(endDate)) {
			throw new DateConflictException("Start Date [" + startDate.toString() + "] and End Date ["
					+ endDate.toString() + "] cannot be on the same day!");
		}

	}

	/**
	 * Process the release of a car request using the rentalId
	 * 
	 * Validates the rental Id, else <b>Throws</b> exception
	 * 
	 * Upon validation, update the new endDate and calculate the new rental charge
	 * fees prior persisting to database
	 * 
	 * @param rentalId
	 * @return <b>True</b> on new update persisted
	 * @throws RentalEntryNotFoundException
	 *             and logs the error status
	 */
	public boolean releaseCar(Long rentalId) throws RentalEntryNotFoundException {

		Rental rtest = rentalRepo.findById(rentalId).get();
		if (rtest != null) {

			// if the return date differs from the schedule date, update the new endDate
			// attribute
			rtest.setEndDate(LocalDate.now());
			// after new endDate change, the new rental fee is recalculated
			Long days = ChronoUnit.DAYS.between(rtest.getStartDate(), rtest.getEndDate());
			Double charges = carRepo.findById(rtest.getCar().getCarId()).get().getPricePerDay() * days;
			rtest.setCharges(charges);
			rtest.setReturned(true);
			rentalRepo.save(rtest);
			logger.info("Car release updated!");
			return true;
		} else {
			logger.error("ErrorStatus: Failed to find the specified rental entry!");
			throw new RentalEntryNotFoundException("Cannot find the specified rental entry!");
		}

	}

	public void updateRentalEntry(Long rentalId) {
		// TODO Auto-generated method stub
		// to changes changes
		// calculate new charges

	}

	/**
	 * @return A list of all the Rental entities from the database
	 */
	public List<Rental> showAllRental() {
		List<Rental> list = new ArrayList<>();

		list = rentalRepo.findAll();
		return list;
	}

	/**
	 * @param carId
	 * @return A list of rented car entities matching the carId from database
	 */
	public List<Car> carsRentedByCarId(Long carId) {
		List<Car> list = new ArrayList<>();
		List<Rental> rlist = new ArrayList<>();

		Car c = carRepo.findById(carId).get();

		c.getRentals().forEach(rlist::add);

		for (Rental r : rlist) {
			list.add(r.getCar());
		}

		return list;
	}

	/**
	 * @param rentalId
	 * @return A Rental entity matching the specified rentalId from the database
	 */
	public Rental findByRentalId(Long rentalId) {

		return rentalRepo.findById(rentalId).get();
	}

	/**
	 * @param carId
	 * @return A list of Rental entries from the database for the specified carId
	 */
	public List<Rental> allRentalByCarId(Long carId) {

		List<Rental> list = rentalRepo.findAllByCarId(carId);

		return list;
	}

	/**
	 * @param userId
	 * @return A list of Rental entries from the database for the specified userId
	 */
	public List<Rental> allRentalByUserId(Long userId) {
		List<Rental> list = rentalRepo.findAllByUserId(userId);

		return list;
	}

	/**
	 * Persist the Rental entity to the database directly
	 * 
	 * @param r
	 */
	public void saveRental(Rental r) {

		rentalRepo.save(r);

	}

	/**
	 * 
	 * @return A List of Rental entities from the database for which car returned
	 *         attribute is false
	 */
	public List<Rental> allCurrentCarOnRent() {
		return rentalRepo.findAllNotReturned();
	}

	public List<Rental> processRentalQuery(RentalDto dto, List<Rental> fetch, Model model) {
		List<Rental> rentalList = new ArrayList<>();

		// filter the fetch list if user queried the registrationNumber attribute
		if (!dto.getRegistrationNumber().equalsIgnoreCase("")) {
			for (Rental r : fetch) {
				if (r.getCar().getRegistrationNumber().equalsIgnoreCase(dto.getRegistrationNumber())) {
					rentalList.add(r);
				}
			}
			// update the fetch list for next filter
			fetch = rentalList;
		}

		// filter the fetch if the user queried the nationalId attribute
		if (!dto.getNationalId().equalsIgnoreCase("")) {
			rentalList = new ArrayList<>(); // flush the filtered list
			for (Rental r : fetch) {
				if (r.getUser().getNationalId().equalsIgnoreCase(dto.getNationalId())) {
					rentalList.add(r);
				}
			}
			// update the fetch list for next filter
			fetch = rentalList;
		}

		// filter the fetch if the user queried the startDate attribute
		try {
			if (dto.getStartDate().isSupported(ChronoUnit.DAYS)) {

				rentalList = new ArrayList<>(); // flush the filtered list
				for (Rental r : fetch) {
					if (r.getStartDate().equals(dto.getStartDate())) {
						rentalList.add(r);
					}
				}
				// update the fetch list for next filter
				fetch = rentalList;
			}
		} catch (Exception e) {

		}

		// filter the fetch if the user queried the endDate attribute
		try {
			if (!dto.getEndDate().isSupported(ChronoUnit.DAYS)) {
				rentalList = new ArrayList<>(); // flush the filtered list
				for (Rental r : fetch) {
					if (r.getEndDate().equals(dto.getEndDate())) {
						rentalList.add(r);
					}
				}
				// update the fetch list for next filter
				fetch = rentalList;
			}
		} catch (Exception e) {

		}

		// filter the fetch if the user queried the amount attribute
		try {
			if (dto.getCharges() != 0.0) {
				rentalList = new ArrayList<>(); // flush the filtered list
				for (Rental r : fetch) {
					if (r.getCharges() == dto.getCharges()) {
						rentalList.add(r);
					}
				}
				// update the fetch list for next filter
				fetch = rentalList;
			}
		} catch (Exception e) {

		}

		// filter the fetch if the user queried the returned attribute
		try {
			if (dto.isReturned() || !dto.isReturned()) {
				rentalList = new ArrayList<>(); // flush the filtered list
				for (Rental r : fetch) {
					if (r.isReturned() == dto.isReturned()) {
						rentalList.add(r);
					}
				}
				// update the fetch list for next filter
				fetch = rentalList;

			}

		} catch (Exception e) {

		}

		return rentalList;
	}

}
